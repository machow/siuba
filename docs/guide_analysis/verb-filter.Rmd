---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.6
  kernelspec:
    display_name: venv-siuba-docs
    language: python
    name: venv-siuba-docs
---

```{python nbsphinx=hidden}
import pandas as pd
pd.set_option("display.max_rows", 5)
```

## Filter rows

This function keeps rows of data that meet all specified conditions.

```{python}
from siuba import _, filter, group_by
from siuba.data import mtcars
```

### Basics


Here is a simple `filter()`.

```{python}
mtcars >> filter(_.cyl == 4, _.gear == 5)
```

It keeps rows where the `cyl` column is equal to 4, **AND** the `gear` column is equal to five.


### Filters with OR conditions

In order to keep a row when one of several conditions is met, use the bar (`|`) operator.

```{python}
mtcars >> filter((_.cyl == 4) | (_.gear == 5))
```

The code above keeps rows where `cyl` is equal to 4 **OR** `gear` is equal to 5.

Be sure to explicitly put parentheses around both sides.
Otherwise, python will group the operation like `_.cyl == (4 | _.gear) == 5`.

### Dropping NA values

Filter drops rows with `False` values or `NA` values.

```{python}
df = pd.DataFrame({
    "x": [True, False, None],
    })

df
```

```{python}
df >> filter(_.x)
```

If you want to remove only NA values from your data, use the pandas `.notna()` method.

This effectively says, "keep any values of x that are not NA".

```{python}
df >> filter(_.x.notna())
```

### Keeping NA values

In `pandas`, there are many values that can represent NAs, and they behave in different ways.

That said, you can usually get away with adding an `OR .isna()` piece to your filter condition.


```{python}
df = pd.DataFrame({
    "some_number": [1.1, None],
    "is_something": [True, None],
})

df
```


This strategy should work almost all the time.

```{python}
(df.some_number > 1) | df.some_number.isna()
```

```{python}
df >> filter((_.some_number > 1) | _.some_number.isna())
```

Sometimes, however this strategy can fail in surprising ways.

```{python}
df.is_something | df.is_something.isna()
```

This happens because the second value in `is_something` is `None`.
For some reason, `pd.Series([None]) | True` evaluates to False.

The easiest way to fix this is to try using `convert_dtypes()`, which tries to change columns into a format with consistent NA representation and handling.

```{python}
fixed = df.convert_dtypes()
fixed
```

```{python}
fixed.is_something | fixed.is_something.isna()
```

```{python}
df >> filter(_.is_something.fillna(True))
```

### Grouped filters


In the example below, we keep rows where the horsepower (hp) is above the median horsepower for each cylinder group. This means that the filter performas the following operations.

* calculates the median `hp` for each `cyl` grouping.
* for each row, based on the `cyl` group it belongs to, tests where the `hp` is greater than the median `hp`.
* keeps only rows where this test passes.

```{python}
(mtcars
  >> group_by(_.cyl)
  >> filter(_.hp > _.hp.median())
  )
```
